//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2016.09.27 at 11:47:51 AM CEST 
//


package jargon.model.folia;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}domain-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}list-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}part-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}phon-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}utterance-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}chunking-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}pos-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}lang-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}alignment-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}statement-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}dependency-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}entry-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}string-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}syntax-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}entity-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}sense-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}division-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}note-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}table-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}sentiment-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}lemma-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}figure-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}sentence-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}term-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}errordetection-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}subjectivity-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}paragraph-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}gap-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}predicate-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}coreference-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}example-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}token-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}phonological-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}text-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}metric-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}morphological-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}complexalignment-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}observation-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}event-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}timesegment-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}correction-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}linebreak-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}style-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}whitespace-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}semrole-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{http://ilk.uvt.nl/folia}definition-annotation" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "domainAnnotation",
    "listAnnotation",
    "partAnnotation",
    "phonAnnotation",
    "utteranceAnnotation",
    "chunkingAnnotation",
    "posAnnotation",
    "langAnnotation",
    "alignmentAnnotation",
    "statementAnnotation",
    "dependencyAnnotation",
    "entryAnnotation",
    "stringAnnotation",
    "syntaxAnnotation",
    "entityAnnotation",
    "senseAnnotation",
    "divisionAnnotation",
    "noteAnnotation",
    "tableAnnotation",
    "sentimentAnnotation",
    "lemmaAnnotation",
    "figureAnnotation",
    "sentenceAnnotation",
    "termAnnotation",
    "errordetectionAnnotation",
    "subjectivityAnnotation",
    "paragraphAnnotation",
    "gapAnnotation",
    "predicateAnnotation",
    "coreferenceAnnotation",
    "exampleAnnotation",
    "tokenAnnotation",
    "phonologicalAnnotation",
    "textAnnotation",
    "metricAnnotation",
    "morphologicalAnnotation",
    "complexalignmentAnnotation",
    "observationAnnotation",
    "eventAnnotation",
    "timesegmentAnnotation",
    "correctionAnnotation",
    "linebreakAnnotation",
    "styleAnnotation",
    "whitespaceAnnotation",
    "semroleAnnotation",
    "definitionAnnotation"
})
@XmlRootElement(name = "annotations")
public class Annotations {

    @XmlElement(name = "domain-annotation")
    protected List<DomainAnnotation> domainAnnotation;
    @XmlElement(name = "list-annotation")
    protected List<ListAnnotation> listAnnotation;
    @XmlElement(name = "part-annotation")
    protected List<PartAnnotation> partAnnotation;
    @XmlElement(name = "phon-annotation")
    protected List<PhonAnnotation> phonAnnotation;
    @XmlElement(name = "utterance-annotation")
    protected List<UtteranceAnnotation> utteranceAnnotation;
    @XmlElement(name = "chunking-annotation")
    protected List<ChunkingAnnotation> chunkingAnnotation;
    @XmlElement(name = "pos-annotation")
    protected List<PosAnnotation> posAnnotation;
    @XmlElement(name = "lang-annotation")
    protected List<LangAnnotation> langAnnotation;
    @XmlElement(name = "alignment-annotation")
    protected List<AlignmentAnnotation> alignmentAnnotation;
    @XmlElement(name = "statement-annotation")
    protected List<StatementAnnotation> statementAnnotation;
    @XmlElement(name = "dependency-annotation")
    protected List<DependencyAnnotation> dependencyAnnotation;
    @XmlElement(name = "entry-annotation")
    protected List<EntryAnnotation> entryAnnotation;
    @XmlElement(name = "string-annotation")
    protected List<StringAnnotation> stringAnnotation;
    @XmlElement(name = "syntax-annotation")
    protected List<SyntaxAnnotation> syntaxAnnotation;
    @XmlElement(name = "entity-annotation")
    protected List<EntityAnnotation> entityAnnotation;
    @XmlElement(name = "sense-annotation")
    protected List<SenseAnnotation> senseAnnotation;
    @XmlElement(name = "division-annotation")
    protected List<DivisionAnnotation> divisionAnnotation;
    @XmlElement(name = "note-annotation")
    protected List<NoteAnnotation> noteAnnotation;
    @XmlElement(name = "table-annotation")
    protected List<TableAnnotation> tableAnnotation;
    @XmlElement(name = "sentiment-annotation")
    protected List<SentimentAnnotation> sentimentAnnotation;
    @XmlElement(name = "lemma-annotation")
    protected List<LemmaAnnotation> lemmaAnnotation;
    @XmlElement(name = "figure-annotation")
    protected List<FigureAnnotation> figureAnnotation;
    @XmlElement(name = "sentence-annotation")
    protected List<SentenceAnnotation> sentenceAnnotation;
    @XmlElement(name = "term-annotation")
    protected List<TermAnnotation> termAnnotation;
    @XmlElement(name = "errordetection-annotation")
    protected List<ErrordetectionAnnotation> errordetectionAnnotation;
    @XmlElement(name = "subjectivity-annotation")
    protected List<SubjectivityAnnotation> subjectivityAnnotation;
    @XmlElement(name = "paragraph-annotation")
    protected List<ParagraphAnnotation> paragraphAnnotation;
    @XmlElement(name = "gap-annotation")
    protected List<GapAnnotation> gapAnnotation;
    @XmlElement(name = "predicate-annotation")
    protected List<PredicateAnnotation> predicateAnnotation;
    @XmlElement(name = "coreference-annotation")
    protected List<CoreferenceAnnotation> coreferenceAnnotation;
    @XmlElement(name = "example-annotation")
    protected List<ExampleAnnotation> exampleAnnotation;
    @XmlElement(name = "token-annotation")
    protected List<TokenAnnotation> tokenAnnotation;
    @XmlElement(name = "phonological-annotation")
    protected List<PhonologicalAnnotation> phonologicalAnnotation;
    @XmlElement(name = "text-annotation")
    protected List<TextAnnotation> textAnnotation;
    @XmlElement(name = "metric-annotation")
    protected List<MetricAnnotation> metricAnnotation;
    @XmlElement(name = "morphological-annotation")
    protected List<MorphologicalAnnotation> morphologicalAnnotation;
    @XmlElement(name = "complexalignment-annotation")
    protected List<ComplexalignmentAnnotation> complexalignmentAnnotation;
    @XmlElement(name = "observation-annotation")
    protected List<ObservationAnnotation> observationAnnotation;
    @XmlElement(name = "event-annotation")
    protected List<EventAnnotation> eventAnnotation;
    @XmlElement(name = "timesegment-annotation")
    protected List<TimesegmentAnnotation> timesegmentAnnotation;
    @XmlElement(name = "correction-annotation")
    protected List<CorrectionAnnotation> correctionAnnotation;
    @XmlElement(name = "linebreak-annotation")
    protected List<LinebreakAnnotation> linebreakAnnotation;
    @XmlElement(name = "style-annotation")
    protected List<StyleAnnotation> styleAnnotation;
    @XmlElement(name = "whitespace-annotation")
    protected List<WhitespaceAnnotation> whitespaceAnnotation;
    @XmlElement(name = "semrole-annotation")
    protected List<SemroleAnnotation> semroleAnnotation;
    @XmlElement(name = "definition-annotation")
    protected List<DefinitionAnnotation> definitionAnnotation;

    /**
     * Gets the value of the domainAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the domainAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDomainAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DomainAnnotation }
     * 
     * 
     */
    public List<DomainAnnotation> getDomainAnnotation() {
        if (domainAnnotation == null) {
            domainAnnotation = new ArrayList<DomainAnnotation>();
        }
        return this.domainAnnotation;
    }

    /**
     * Gets the value of the listAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the listAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getListAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ListAnnotation }
     * 
     * 
     */
    public List<ListAnnotation> getListAnnotation() {
        if (listAnnotation == null) {
            listAnnotation = new ArrayList<ListAnnotation>();
        }
        return this.listAnnotation;
    }

    /**
     * Gets the value of the partAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the partAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPartAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PartAnnotation }
     * 
     * 
     */
    public List<PartAnnotation> getPartAnnotation() {
        if (partAnnotation == null) {
            partAnnotation = new ArrayList<PartAnnotation>();
        }
        return this.partAnnotation;
    }

    /**
     * Gets the value of the phonAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the phonAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhonAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhonAnnotation }
     * 
     * 
     */
    public List<PhonAnnotation> getPhonAnnotation() {
        if (phonAnnotation == null) {
            phonAnnotation = new ArrayList<PhonAnnotation>();
        }
        return this.phonAnnotation;
    }

    /**
     * Gets the value of the utteranceAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the utteranceAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getUtteranceAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link UtteranceAnnotation }
     * 
     * 
     */
    public List<UtteranceAnnotation> getUtteranceAnnotation() {
        if (utteranceAnnotation == null) {
            utteranceAnnotation = new ArrayList<UtteranceAnnotation>();
        }
        return this.utteranceAnnotation;
    }

    /**
     * Gets the value of the chunkingAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the chunkingAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getChunkingAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ChunkingAnnotation }
     * 
     * 
     */
    public List<ChunkingAnnotation> getChunkingAnnotation() {
        if (chunkingAnnotation == null) {
            chunkingAnnotation = new ArrayList<ChunkingAnnotation>();
        }
        return this.chunkingAnnotation;
    }

    /**
     * Gets the value of the posAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the posAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPosAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PosAnnotation }
     * 
     * 
     */
    public List<PosAnnotation> getPosAnnotation() {
        if (posAnnotation == null) {
            posAnnotation = new ArrayList<PosAnnotation>();
        }
        return this.posAnnotation;
    }

    /**
     * Gets the value of the langAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the langAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLangAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LangAnnotation }
     * 
     * 
     */
    public List<LangAnnotation> getLangAnnotation() {
        if (langAnnotation == null) {
            langAnnotation = new ArrayList<LangAnnotation>();
        }
        return this.langAnnotation;
    }

    /**
     * Gets the value of the alignmentAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the alignmentAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAlignmentAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link AlignmentAnnotation }
     * 
     * 
     */
    public List<AlignmentAnnotation> getAlignmentAnnotation() {
        if (alignmentAnnotation == null) {
            alignmentAnnotation = new ArrayList<AlignmentAnnotation>();
        }
        return this.alignmentAnnotation;
    }

    /**
     * Gets the value of the statementAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the statementAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getStatementAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link StatementAnnotation }
     * 
     * 
     */
    public List<StatementAnnotation> getStatementAnnotation() {
        if (statementAnnotation == null) {
            statementAnnotation = new ArrayList<StatementAnnotation>();
        }
        return this.statementAnnotation;
    }

    /**
     * Gets the value of the dependencyAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dependencyAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDependencyAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DependencyAnnotation }
     * 
     * 
     */
    public List<DependencyAnnotation> getDependencyAnnotation() {
        if (dependencyAnnotation == null) {
            dependencyAnnotation = new ArrayList<DependencyAnnotation>();
        }
        return this.dependencyAnnotation;
    }

    /**
     * Gets the value of the entryAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the entryAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEntryAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntryAnnotation }
     * 
     * 
     */
    public List<EntryAnnotation> getEntryAnnotation() {
        if (entryAnnotation == null) {
            entryAnnotation = new ArrayList<EntryAnnotation>();
        }
        return this.entryAnnotation;
    }

    /**
     * Gets the value of the stringAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the stringAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getStringAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link StringAnnotation }
     * 
     * 
     */
    public List<StringAnnotation> getStringAnnotation() {
        if (stringAnnotation == null) {
            stringAnnotation = new ArrayList<StringAnnotation>();
        }
        return this.stringAnnotation;
    }

    /**
     * Gets the value of the syntaxAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the syntaxAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSyntaxAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SyntaxAnnotation }
     * 
     * 
     */
    public List<SyntaxAnnotation> getSyntaxAnnotation() {
        if (syntaxAnnotation == null) {
            syntaxAnnotation = new ArrayList<SyntaxAnnotation>();
        }
        return this.syntaxAnnotation;
    }

    /**
     * Gets the value of the entityAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the entityAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEntityAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityAnnotation }
     * 
     * 
     */
    public List<EntityAnnotation> getEntityAnnotation() {
        if (entityAnnotation == null) {
            entityAnnotation = new ArrayList<EntityAnnotation>();
        }
        return this.entityAnnotation;
    }

    /**
     * Gets the value of the senseAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the senseAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSenseAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SenseAnnotation }
     * 
     * 
     */
    public List<SenseAnnotation> getSenseAnnotation() {
        if (senseAnnotation == null) {
            senseAnnotation = new ArrayList<SenseAnnotation>();
        }
        return this.senseAnnotation;
    }

    /**
     * Gets the value of the divisionAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the divisionAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDivisionAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DivisionAnnotation }
     * 
     * 
     */
    public List<DivisionAnnotation> getDivisionAnnotation() {
        if (divisionAnnotation == null) {
            divisionAnnotation = new ArrayList<DivisionAnnotation>();
        }
        return this.divisionAnnotation;
    }

    /**
     * Gets the value of the noteAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the noteAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNoteAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NoteAnnotation }
     * 
     * 
     */
    public List<NoteAnnotation> getNoteAnnotation() {
        if (noteAnnotation == null) {
            noteAnnotation = new ArrayList<NoteAnnotation>();
        }
        return this.noteAnnotation;
    }

    /**
     * Gets the value of the tableAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the tableAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTableAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TableAnnotation }
     * 
     * 
     */
    public List<TableAnnotation> getTableAnnotation() {
        if (tableAnnotation == null) {
            tableAnnotation = new ArrayList<TableAnnotation>();
        }
        return this.tableAnnotation;
    }

    /**
     * Gets the value of the sentimentAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sentimentAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSentimentAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SentimentAnnotation }
     * 
     * 
     */
    public List<SentimentAnnotation> getSentimentAnnotation() {
        if (sentimentAnnotation == null) {
            sentimentAnnotation = new ArrayList<SentimentAnnotation>();
        }
        return this.sentimentAnnotation;
    }

    /**
     * Gets the value of the lemmaAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the lemmaAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLemmaAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LemmaAnnotation }
     * 
     * 
     */
    public List<LemmaAnnotation> getLemmaAnnotation() {
        if (lemmaAnnotation == null) {
            lemmaAnnotation = new ArrayList<LemmaAnnotation>();
        }
        return this.lemmaAnnotation;
    }

    /**
     * Gets the value of the figureAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the figureAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFigureAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FigureAnnotation }
     * 
     * 
     */
    public List<FigureAnnotation> getFigureAnnotation() {
        if (figureAnnotation == null) {
            figureAnnotation = new ArrayList<FigureAnnotation>();
        }
        return this.figureAnnotation;
    }

    /**
     * Gets the value of the sentenceAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sentenceAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSentenceAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SentenceAnnotation }
     * 
     * 
     */
    public List<SentenceAnnotation> getSentenceAnnotation() {
        if (sentenceAnnotation == null) {
            sentenceAnnotation = new ArrayList<SentenceAnnotation>();
        }
        return this.sentenceAnnotation;
    }

    /**
     * Gets the value of the termAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the termAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTermAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TermAnnotation }
     * 
     * 
     */
    public List<TermAnnotation> getTermAnnotation() {
        if (termAnnotation == null) {
            termAnnotation = new ArrayList<TermAnnotation>();
        }
        return this.termAnnotation;
    }

    /**
     * Gets the value of the errordetectionAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the errordetectionAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getErrordetectionAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ErrordetectionAnnotation }
     * 
     * 
     */
    public List<ErrordetectionAnnotation> getErrordetectionAnnotation() {
        if (errordetectionAnnotation == null) {
            errordetectionAnnotation = new ArrayList<ErrordetectionAnnotation>();
        }
        return this.errordetectionAnnotation;
    }

    /**
     * Gets the value of the subjectivityAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subjectivityAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubjectivityAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SubjectivityAnnotation }
     * 
     * 
     */
    public List<SubjectivityAnnotation> getSubjectivityAnnotation() {
        if (subjectivityAnnotation == null) {
            subjectivityAnnotation = new ArrayList<SubjectivityAnnotation>();
        }
        return this.subjectivityAnnotation;
    }

    /**
     * Gets the value of the paragraphAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the paragraphAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getParagraphAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ParagraphAnnotation }
     * 
     * 
     */
    public List<ParagraphAnnotation> getParagraphAnnotation() {
        if (paragraphAnnotation == null) {
            paragraphAnnotation = new ArrayList<ParagraphAnnotation>();
        }
        return this.paragraphAnnotation;
    }

    /**
     * Gets the value of the gapAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the gapAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGapAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GapAnnotation }
     * 
     * 
     */
    public List<GapAnnotation> getGapAnnotation() {
        if (gapAnnotation == null) {
            gapAnnotation = new ArrayList<GapAnnotation>();
        }
        return this.gapAnnotation;
    }

    /**
     * Gets the value of the predicateAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the predicateAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPredicateAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PredicateAnnotation }
     * 
     * 
     */
    public List<PredicateAnnotation> getPredicateAnnotation() {
        if (predicateAnnotation == null) {
            predicateAnnotation = new ArrayList<PredicateAnnotation>();
        }
        return this.predicateAnnotation;
    }

    /**
     * Gets the value of the coreferenceAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the coreferenceAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCoreferenceAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CoreferenceAnnotation }
     * 
     * 
     */
    public List<CoreferenceAnnotation> getCoreferenceAnnotation() {
        if (coreferenceAnnotation == null) {
            coreferenceAnnotation = new ArrayList<CoreferenceAnnotation>();
        }
        return this.coreferenceAnnotation;
    }

    /**
     * Gets the value of the exampleAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the exampleAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getExampleAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ExampleAnnotation }
     * 
     * 
     */
    public List<ExampleAnnotation> getExampleAnnotation() {
        if (exampleAnnotation == null) {
            exampleAnnotation = new ArrayList<ExampleAnnotation>();
        }
        return this.exampleAnnotation;
    }

    /**
     * Gets the value of the tokenAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the tokenAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTokenAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TokenAnnotation }
     * 
     * 
     */
    public List<TokenAnnotation> getTokenAnnotation() {
        if (tokenAnnotation == null) {
            tokenAnnotation = new ArrayList<TokenAnnotation>();
        }
        return this.tokenAnnotation;
    }

    /**
     * Gets the value of the phonologicalAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the phonologicalAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhonologicalAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhonologicalAnnotation }
     * 
     * 
     */
    public List<PhonologicalAnnotation> getPhonologicalAnnotation() {
        if (phonologicalAnnotation == null) {
            phonologicalAnnotation = new ArrayList<PhonologicalAnnotation>();
        }
        return this.phonologicalAnnotation;
    }

    /**
     * Gets the value of the textAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the textAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTextAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TextAnnotation }
     * 
     * 
     */
    public List<TextAnnotation> getTextAnnotation() {
        if (textAnnotation == null) {
            textAnnotation = new ArrayList<TextAnnotation>();
        }
        return this.textAnnotation;
    }

    /**
     * Gets the value of the metricAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the metricAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMetricAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MetricAnnotation }
     * 
     * 
     */
    public List<MetricAnnotation> getMetricAnnotation() {
        if (metricAnnotation == null) {
            metricAnnotation = new ArrayList<MetricAnnotation>();
        }
        return this.metricAnnotation;
    }

    /**
     * Gets the value of the morphologicalAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the morphologicalAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMorphologicalAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MorphologicalAnnotation }
     * 
     * 
     */
    public List<MorphologicalAnnotation> getMorphologicalAnnotation() {
        if (morphologicalAnnotation == null) {
            morphologicalAnnotation = new ArrayList<MorphologicalAnnotation>();
        }
        return this.morphologicalAnnotation;
    }

    /**
     * Gets the value of the complexalignmentAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the complexalignmentAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getComplexalignmentAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ComplexalignmentAnnotation }
     * 
     * 
     */
    public List<ComplexalignmentAnnotation> getComplexalignmentAnnotation() {
        if (complexalignmentAnnotation == null) {
            complexalignmentAnnotation = new ArrayList<ComplexalignmentAnnotation>();
        }
        return this.complexalignmentAnnotation;
    }

    /**
     * Gets the value of the observationAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the observationAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getObservationAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ObservationAnnotation }
     * 
     * 
     */
    public List<ObservationAnnotation> getObservationAnnotation() {
        if (observationAnnotation == null) {
            observationAnnotation = new ArrayList<ObservationAnnotation>();
        }
        return this.observationAnnotation;
    }

    /**
     * Gets the value of the eventAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the eventAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEventAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EventAnnotation }
     * 
     * 
     */
    public List<EventAnnotation> getEventAnnotation() {
        if (eventAnnotation == null) {
            eventAnnotation = new ArrayList<EventAnnotation>();
        }
        return this.eventAnnotation;
    }

    /**
     * Gets the value of the timesegmentAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the timesegmentAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTimesegmentAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TimesegmentAnnotation }
     * 
     * 
     */
    public List<TimesegmentAnnotation> getTimesegmentAnnotation() {
        if (timesegmentAnnotation == null) {
            timesegmentAnnotation = new ArrayList<TimesegmentAnnotation>();
        }
        return this.timesegmentAnnotation;
    }

    /**
     * Gets the value of the correctionAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the correctionAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCorrectionAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CorrectionAnnotation }
     * 
     * 
     */
    public List<CorrectionAnnotation> getCorrectionAnnotation() {
        if (correctionAnnotation == null) {
            correctionAnnotation = new ArrayList<CorrectionAnnotation>();
        }
        return this.correctionAnnotation;
    }

    /**
     * Gets the value of the linebreakAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the linebreakAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLinebreakAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LinebreakAnnotation }
     * 
     * 
     */
    public List<LinebreakAnnotation> getLinebreakAnnotation() {
        if (linebreakAnnotation == null) {
            linebreakAnnotation = new ArrayList<LinebreakAnnotation>();
        }
        return this.linebreakAnnotation;
    }

    /**
     * Gets the value of the styleAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the styleAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getStyleAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link StyleAnnotation }
     * 
     * 
     */
    public List<StyleAnnotation> getStyleAnnotation() {
        if (styleAnnotation == null) {
            styleAnnotation = new ArrayList<StyleAnnotation>();
        }
        return this.styleAnnotation;
    }

    /**
     * Gets the value of the whitespaceAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the whitespaceAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWhitespaceAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link WhitespaceAnnotation }
     * 
     * 
     */
    public List<WhitespaceAnnotation> getWhitespaceAnnotation() {
        if (whitespaceAnnotation == null) {
            whitespaceAnnotation = new ArrayList<WhitespaceAnnotation>();
        }
        return this.whitespaceAnnotation;
    }

    /**
     * Gets the value of the semroleAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the semroleAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSemroleAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SemroleAnnotation }
     * 
     * 
     */
    public List<SemroleAnnotation> getSemroleAnnotation() {
        if (semroleAnnotation == null) {
            semroleAnnotation = new ArrayList<SemroleAnnotation>();
        }
        return this.semroleAnnotation;
    }

    /**
     * Gets the value of the definitionAnnotation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the definitionAnnotation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDefinitionAnnotation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DefinitionAnnotation }
     * 
     * 
     */
    public List<DefinitionAnnotation> getDefinitionAnnotation() {
        if (definitionAnnotation == null) {
            definitionAnnotation = new ArrayList<DefinitionAnnotation>();
        }
        return this.definitionAnnotation;
    }

}
